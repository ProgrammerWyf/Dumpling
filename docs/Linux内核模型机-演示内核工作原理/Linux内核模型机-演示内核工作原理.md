<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [linux内核-用模型机演示内核工作原理-理想化模型~](#linux内核-用模型机演示内核工作原理-理想化模型)
	- [设计一个简单的计算机解释内核工作方式](#设计一个简单的计算机解释内核工作方式)
		- [鼠标键盘等外设-中断](#鼠标键盘等外设-中断)
		- [内核是如何设计的？](#内核是如何设计的)
	- [总结](#总结)

<!-- /TOC -->

# linux内核-用模型机演示内核工作原理-理想化模型~

## 设计一个简单的计算机解释内核工作方式

![1530173824063.png](image/1530173824063.png)

![1530173865320.png](image/1530173865320.png)

* 从原理上来讲解内核工作，很多内容跟硬件打交道的都抽象化，直接拿来用。不管具体实现。
* 只针对核心模块及模块间的引用关系进行讲解

![1530173964638.png](image/1530173964638.png)

* 采用乌托邦式的架构模式
* CPU一通电就从软盘读取内核，然后从光盘加载文件系统（获取应用程序）
* 内核本身很复杂，但是依然是分成数据和代码

![1530174129521.png](image/1530174129521.png)

![1530174116970.png](image/1530174116970.png)

* 简化模型，直接调用内核函数。真实内核需要进行系统调用
* 应用开发基于C库写程序。但是C库依然是调用内核函数or系统调用

![1530174252681.png](image/1530174252681.png)

![1530174278534.png](image/1530174278534.png)

![1530174361209.png](image/1530174361209.png)

* 内核虽然很复杂，对应用来说只是提供函数，APP代码逻辑调用内核函数。完成APP应有的功能。

![1530174436934.png](image/1530174436934.png)

![1530174463849.png](image/1530174463849.png)

* 如果想给内核增加功能，增加内核函数就是
* 把内核初始化放到内核代码区头部，EOP开头部分

![1530174624064.png](image/1530174624064.png)

![1530174660858.png](image/1530174660858.png)

* 定时器其实就是CPU内部组件，周期性发送信号

![1530174766974.png](image/1530174766974.png)

![1530174911519.png](image/1530174911519.png)


![1530174995194.png](image/1530174995194.png)

![1530175236426.png](image/1530175236426.png)

* 设定闹钟，定时切换。每次调度切换下一次调用进程1,2,3,4，然后置位1。多傻瓜多简单
* 忽略了进程运行环境的保存，这个切换过程中，调度程序多复杂，其实本质都只是保存环境
* 调度算法什么的，其实都是细节性的，对于理解内核工作不重要。你只要知道定时器周期性执行某个函数，这个就很简单。

![1530175378721.png](image/1530175378721.png)

* 如果需要增加功能，统计内存使用数量，那么在schedule()里面添加统计函数

![1530176034337.png](image/1530176034337.png)

* 创建数组，初始化0作为进程队列
* fork内部执行funstatisc()统计信息放到内核数据结构中
* 先创造一个内核数据结构，然后提供使用该数据结构的函数，然后应用程序调用该函数。

![1530176152999.png](image/1530176152999.png)

![1530176163788.png](image/1530176163788.png)

* 信号机制-进程间通信
* 信号创建之后会存放到内核数据结构中，涉及到该目标进程的数据区，代码中添加信号检查，如果有信号就进行相应处理，否则略过。

![1530176323670.png](image/1530176323670.png)

![1530176424036.png](image/1530176424036.png)

* 调度程序铜鼓哦内核数据（进程数据）进行相应的处理.
* 内核首先提供数据结构（数据表、进程表）记录进程是否有信号要处理，如果有信号标记，进行相应处理，否则略过
* 内核会定期，周期性调用调度程序。在调度过程中进行信号检查。

![1530176620805.png](image/1530176620805.png)

* 这个图很重要。

![1530176643277.png](image/1530176643277.png)

* 通过修改/proc目录下的某些文件就可以修改内核参数，其实本质就是内核数据。
* 所以就是围绕代码和数据的运算。

### 鼠标键盘等外设-中断

![1530178233735.png](image/1530178233735.png)

* 外设信号传递给CPU

![1530178287549.png](image/1530178287549.png)

![1530178338647.png](image/1530178338647.png)

![1530178366771.png](image/1530178366771.png)

* 内核、应用程序、驱动程序，典型的键盘按键，内核接收传递信号，驱动处理信号，反馈到用户数据区，用户程序即可显示。

![1530178543190.png](image/1530178543190.png)

* 中断-软中断-上半部分、下半部分
* 外设已经可以拥有CPU和内存，处理器和处理器通信。外设没有那么简单。

![1530178634797.png](image/1530178634797.png)



 ### 改进一

![1530179551262.png](image/1530179551262.png)

![1530179761222.png](image/1530179761222.png)

* 最早的内核开发者靠提供内核函数进行开发。内核把一些功能外包给C库
* 划分内核空间、用户进程空间。减轻了编译器的工作

![1530180545891.png](image/1530180545891.png)

![1530180618507.png](image/1530180618507.png)

![1530180655228.png](image/1530180655228.png)

* CPU、编译器、内核共同协作。尽可能加快速度，所以CPU添加了硬件MMU支持，内核提供新的函数和数据结构，编译器生成的应用程序从0开始的地址空间来部署程序地址空间。
* CPU的设计不是死板的，是提供更多、更高效的指令集给开发人员。

![1530181217565.png](image/1530181217565.png)

![1530190249836.png](image/1530190249836.png)

* 神奇的地址转换，其实主要是软件负责虚拟内存，但是性能不得行，所以硬件出手了。
* 内核如果要提供相应的功能，就要添加相应的函数，并且在初始化函数里面添加相应函数的初始化。


![1530190475787.png](image/1530190475787.png)

* 神奇的带间谍的CPU~，当你输入密码的时候会把信息记录在内存中。内核不单单执行内核代码，还需要跟CPU完美协作。
* CPU自带功能可以理解成一个程序，CPU自带的程序，有些事情必须由CPU来做~

![1530190573979.png](image/1530190573979.png)

* CPU可以更复杂，但是CPU多是兼容，所以最简单的OS也是可以，不需要支持相应的特性即可。

![1530190655655.png](image/1530190655655.png)

* CPU体系决定了主板必须符合什么样的规则才能使用。内核书籍不会讲到，但是你必须知道这一点，虽然这个知识点很弱智。


![1530190753087.png](image/1530190753087.png)

![1530190813540.png](image/1530190813540.png)


![1530190874205.png](image/1530190874205.png)

* 历史上文件系统是怎么过渡出来的？
* 内核中有相应的设备结构信息，而文件系统中存放设备号。
* 打开设备像打开文件一样

![1530191144475.png](image/1530191144475.png)

* 在open系统调用中判断是设备还是文件。

![1530191199266.png](image/1530191199266.png)

![1530191308065.png](image/1530191308065.png)

![1530191541554.png](image/1530191541554.png)

![1530191635048.png](image/1530191635048.png)


![1530191670889.png](image/1530191670889.png)

![1530191689961.png](image/1530191689961.png)

* 硬盘开发和键盘驱动开发，都提供了文件系统中新的设备文件，这点非常重要。
* 硬盘提供了新的设备文件的格式，内核提供设备号和存储设备对应的数据结构。
* 应用程序提供设备号就行了，然后去内核中根据设备号找到对应的数据结构，执行相应的函数，这些函数可以是设备驱动厂商提供。

![1530191865493.png](image/1530191865493.png)


![1530191893066.png](image/1530191893066.png)


![1530191937712.png](image/1530191937712.png)


![1530192014018.png](image/1530192014018.png)

* 就像注册表一样，该文件内容就修改了内核参数

![1530192247967.png](image/1530192247967.png)

* 举例来说，/proc/devbam,文件打开的时候会做各种判断，他其实就是内核数据结构中某个值
* 改变内核调度程序，修改/proc/schedule即可。。当然只是智障做法。
* 内核的很大一部分功能就是这么实现的。
* multics是一个分时操作系统，该系统开始作为一个合资项目，是1964年由贝尔实验室、麻省理工学院及美国通用电气公司所共同参与研发的，其目的是为了开发出一套安装在大型主机上多人多工的操作系统。
* 但是multics太复杂了，所以死的很快
* 但是UNIX操作系统很精简，甚至很多大学生都可以轻松愉快上手，就是因为他的涉及非常简洁，原理简单。简化内核设计，把功能划分开来，可以借助编译器和CPU
* SMP中如何仲裁？都是可以由CPU来完成。

![1530192513019.png](image/1530192513019.png)

* 什么流？打电话

![1530192763599.png](image/1530192763599.png)

![1530192779271.png](image/1530192779271.png)

* 不断复杂化原型机，就可以知晓内核工作原理

![1530192821371.png](image/1530192821371.png)

### 内核是如何设计的？

* y=kx，为什么会有酱紫的功能？？？

![1530192863951.png](image/1530192863951.png)

![1530192877166.png](image/1530192877166.png)

![1530192894639.png](image/1530192894639.png)

![1530192929640.png](image/1530192929640.png)

![1530193026633.png](image/1530193026633.png)

![1530193054328.png](image/1530193054328.png)

![1530193066686.png](image/1530193066686.png)

![1530193096312.png](image/1530193096312.png)

* 多线程是放在pthread，单独的库，这是个很神奇的地方哦~

![1530193141567.png](image/1530193141567.png)

![1530193163348.png](image/1530193163348.png)

* 没有一个整体架构，所以才会显得很凌乱。但是如果你仅仅给一个公式就能够表达清楚，那岂不是很容易

![1530193223177.png](image/1530193223177.png)

* 如果你有了原则，整个代码设计就会很有规范，并且，可以合并多项式哦~

![1530193352053.png](image/1530193352053.png)


* 早期内核开发，他知道内核的线性关系，知道枝干，枝叶

![1530193376609.png](image/1530193376609.png)

![1530193434233.png](image/1530193434233.png)

* 各个模块有专有人员来维护，而Linus大佬只是审核是否要加入大模块以及模块间合并关系等等
* 当然这个活估计很气



![1530240461873.png](image/1530240461873.png)

![1530240643472.png](image/1530240643472.png)

* 很多解释内核工作的书籍，其中大部分内容，80%必不可少的去介绍现有内核结构相关知识，但是对于内核如果工作的解释几乎都是忽略掉的。简单的说他们没有扯到点子上
* 现实中内核是不断去掉抽象变成现实，但是理解内核必须不断去掉实现进而去理解抽象的部分。
* 数学家-发现规律，用数学的方法和工具去描述他们。
* 使用数学简化模型 - 简化操作系统 - 理解内核工作原理


![1530240852444.png](image/1530240852444.png)

* 对数学家而言，模型机的简化和推理是很虚弱的


![1530241008736.png](image/1530241008736.png)

* 大佬们看代码看一遍就知道怎么回事。看内核代码，看一遍就知道是在干啥。不是要记下来，而是就是知道它是干啥了。


![1530241246300.png](image/1530241246300.png)


![1530241257428.png](image/1530241257428.png)

* 爱尔兰大佬，一开始也是个菜鸟。自己玩了两年时间来玩耍Linux内存管理，两年时间研究内存管理。很多注释上依然可以看懂他还是没有完全搞通透。
* 成为一段代码的砖家就好了
* 如果对这个分享感觉有所帮助，再去看其他入门书籍，这些东西不能带来实际上的物质利益，要攀爬更高就需要研究某某子系统。

![1530241435254.png](image/1530241435254.png)

* 国内数学家为嘛研究内核的很少？？？？？


![1530241464041.png](image/1530241464041.png)

* 德国大佬写的书籍
* 数学符号 - 使用大家都熟知的符号，但如果一篇论文里面包含了超级多新的符号，这个时候就算大佬也会懵逼。所以数学家入门难，搞不通透也很正常。
* 如果数学家参与到Linux内核开发中呢？估计吊炸天喽~
* Linux内核就是一堆全新的符号堆积而成。就算了解了这些符号，怎么用，能不能上天是另一回事儿~~

















## 总结

* 清晰明了，通俗易懂的乌托邦内核原理
* B站链接:<https://www.bilibili.com/video/av21049129/?p=1/>
